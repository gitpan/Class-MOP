
package # hide the package from PAUSE
    ClassEncapsulatedAttributes;

use strict;
use warnings;

use Class::MOP 'meta';

our $VERSION = '0.01';

use base 'Class::MOP::Class';

sub construct_instance {
    my ($class, %params) = @_;
    my $instance = {};
    foreach my $current_class ($class->class_precedence_list()) {
        $instance->{$current_class} = {} 
            unless exists $instance->{$current_class};
        my $meta = $class->initialize($current_class);
        foreach my $attr_name ($meta->get_attribute_list()) {
            my $attr = $meta->get_attribute($attr_name);
            # if the attr has an init_arg, use that, otherwise,
            # use the attributes name itself as the init_arg
            my $init_arg = $attr->has_init_arg() ? $attr->init_arg() : $attr->name;
            # try to fetch the init arg from the %params ...
            my $val;        
            $val = $params{$current_class}->{$init_arg} 
                if exists $params{$current_class} && 
                   exists ${$params{$current_class}}{$init_arg};
            # if nothing was in the %params, we can use the 
            # attribute's default value (if it has one)
            $val ||= $attr->default($instance) if $attr->has_default();
            # now add this to the instance structure
            $instance->{$current_class}->{$attr_name} = $val;
        }
    }  
    return $instance;
}

package # hide the package from PAUSE
    ClassEncapsulatedAttributes::Attribute;

use strict;
use warnings;

use Class::MOP 'meta';

our $VERSION = '0.01';

use base 'Class::MOP::Attribute';

sub generate_accessor_method {
    my ($self, $attr_name) = @_;
    my $class_name = $self->associated_class->name;
    eval qq{sub {
        \$_[0]->{'$class_name'}->{'$attr_name'} = \$_[1] if scalar(\@_) == 2;
        \$_[0]->{'$class_name'}->{'$attr_name'};
    }};
}

sub generate_reader_method {
    my ($self, $attr_name) = @_; 
    my $class_name = $self->associated_class->name;
    eval qq{sub {
        \$_[0]->{'$class_name'}->{'$attr_name'};
    }};   
}

sub generate_writer_method {
    my ($self, $attr_name) = @_; 
    my $class_name = $self->associated_class->name;    
    eval qq{sub {
        \$_[0]->{'$class_name'}->{'$attr_name'} = \$_[1];
    }};
}

sub generate_predicate_method {
    my ($self, $attr_name) = @_; 
    my $class_name = $self->associated_class->name;    
    eval qq{sub {
        defined \$_[0]->{'$class_name'}->{'$attr_name'} ? 1 : 0;
    }};
}

## &remove_attribute is left as an exercise for the reader :)

1;

__END__

=pod

=head1 NAME

ClassEncapsulatedAttributes - A set of example metaclasses with class encapsulated attributes

=head1 SYNOPSIS

  package Foo;
  
  sub meta { ClassEncapsulatedAttributes->initialize($_[0]) }
  
  Foo->meta->add_attribute(
      ClassEncapsulatedAttributes::Attribute->new('foo' => (
          accessor  => 'Foo_foo',
          default   => 'init in FOO'
      ))
  );   
  
  sub new  {
      my $class = shift;
      bless $class->meta->construct_instance(@_) => $class;
  }
  
  package Bar;
  our @ISA = ('Foo');
  
  # duplicate the attribute name here
  Bar->meta->add_attribute(
      ClassEncapsulatedAttributes::Attribute->new('foo' => (
          accessor  => 'Bar_foo',
          default   => 'init in BAR'            
      ))
  );      
  
  # ... later in other code ...
  
  my $bar = Bar->new();
  prints $bar->Bar_foo(); # init in BAR
  prints $bar->Foo_foo(); # init in FOO  
  
  # and ...
  
  my $bar = Bar->new(
      'Foo' => { 'foo' => 'Foo::foo' },
      'Bar' => { 'foo' => 'Bar::foo' }        
  );  
  
  prints $bar->Bar_foo(); # Foo::foo
  prints $bar->Foo_foo(); # Bar::foo  
  
=head1 DESCRIPTION

This is an example metaclass which encapsulates a class's 
attributes on a per-class basis. This means that there is no
possibility of name clashes with inherited attributes. This 
is similar to how C++ handles its data members. 

=head1 ACKNOWLEDGEMENTS

Thanks to Yuval "nothingmuch" Kogman for the idea for this example.

=head1 AUTHOR

Stevan Little E<lt>stevan@iinteractive.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright 2006 by Infinity Interactive, Inc.

L<http://www.iinteractive.com>

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 

=cut
